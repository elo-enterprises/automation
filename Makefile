MAKEFLAGS += --warn-undefined-variables

# NOTE: `firstword` below gives top-level Makefile,
# whereas `lastword` gives the last included Makefile
# current_dir := $(notdir $(patsubst %/,%,$(dir $(mkfile_path))))
THIS_MAKEFILE = $(abspath $(firstword $(MAKEFILE_LIST)))
SRC_ROOT := $(shell dirname ${THIS_MAKEFILE})
MAKE_INCLUDES_DIR := ${SRC_ROOT}/makefiles

# Makefile.base.mk:
#   Load essentials like user-output conveniences and some
#   metatooling for working with asserts/requires in Makefiles
# Makefile.ssh.mk:
#   Load `ssh-generic` and `rsync` targets
# Makefile.docker.mk:
#   Load targets for common docker workflows
# Makefile.ansible.mk:
#   Load targets for common ansible workflows
# Makefile.ansible-vault.mk :
#   Load targets for lightweight encryption helpers with ansible-vault
# Makefile.tf.mk:
#   Load targets for common terraform workflows
# Makefile.json.mk:
#   Load targets for transforming JSON and YAML with pipes
include ${MAKE_INCLUDES_DIR}/Makefile.self.mk
include ${MAKE_INCLUDES_DIR}/Makefile.base.mk
include ${MAKE_INCLUDES_DIR}/Makefile.ssh.mk
include ${MAKE_INCLUDES_DIR}/Makefile.docker.mk
include ${MAKE_INCLUDES_DIR}/Makefile.ansible.mk
include ${MAKE_INCLUDES_DIR}/Makefile.ansible-vault.mk
include ${MAKE_INCLUDES_DIR}/Makefile.tf.mk
include ${MAKE_INCLUDES_DIR}/Makefile.json.mk

# example: useful toplevel variables
APP_NAME = "app"
APP_ROOT = "${SRC_ROOT}/${APP_NAME}"
APP_HOST = "app.server"
APP_HOST_USER="ubuntu"
APP_HOST_KEY = "~/.ssh/local.file"
APP_ROOT = "${SRC_ROOT}/${APP_NAME}"
APP_DEPLOY_ROOT = "/srv/app/.be..careful..with..tilda..expansion"

# example: a target that requires 2 env-vars announces itself when it begins
needy: assert-ENVVAR1 assert-ENVVAR2
	$(call _announce_target, $@)
	echo "Happy now since I got $$ENVVAR1 and $$ENVVAR2"

# example: Deploy this project dir to app-host
sync:
  RSYNC_USER=${APP_HOST_USER} RSYNC_HOST=${APP_HOST} \
  RSYNC_KEY=${APP_HOST_KEY} RSYNC_SRC=${APP_ROOT}/* \
  RSYNC_DEST=${APP_DEPLOY_ROOT} \
  make rsync

# example: target to connect via SSH to the standard app host
ssh:
	SSH_USER=${APP_HOST_USER} SSH_HOST=${APP_HOST} \
	SSH_KEY=${APP_HOST_key} make ssh-generic

# example: target chaining to the `ssh` target to run a specific command
remote-cmd:
	SSH_CMD="echo \"helloworld\"" make ssh

# example: a target chaining to `service-shell` (in Makefile.docker.mk).
# this will start a bash shell inside a container on the remote host
remote-container-shell:
	SERVICE=${APP_NAME} COMPOSE_FILE=${APP_DEPLOY_ROOT}/docker-compose.yml \
	SERVICE_USER=root make service-shell

# composite example: dump terraform output into a format ansible can use.  this
# obviously requires terraform and working, accessible terraform state.  the
# target below combines other targets from Makefile.json.mk, Makefile.tf.mk and
# Makefile.ansible.mk
ANSIBLE_VARS_TF = ${ANSIBLE_ROOT}/terraform.yml
refresh-ansible-vars:
	$(call _announce_target, $@)
	@printf "#\n# DO NOT EDIT MANUALLY!\n#\n" > ${ANSIBLE_VARS_TF}
	@printf "# This file is automatically generated from terraform's output" >> ${ANSIBLE_VARS_TF}
	@printf "# See the 'refresh-ansible-vars' target in environment Makefile's\n" >> ${ANSIBLE_VARS_TF}
	@terraform output -json | wrapper=terraform make json-wrap | make json-to-yaml >> ${ANSIBLE_VARS_TF}

# example: force ansible playbook choice of "$host.yml" for inventory "$host,"
provision-host:
